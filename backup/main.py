#
# Copyright 2023 Jaroslav Chmurny
#
# This file is part of Rudimentary Backup.
#
# Rudimentary Backup is free software. It is licensed under the Apache
# License, Version 2.0 # (the "License"); you may not use this file except
# in compliance with the # License. You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

from argparse import ArgumentParser, Namespace, RawTextHelpFormatter
from datetime import datetime
from os import makedirs
from os.path import join

from rich.console import Console
from rich.table import Table

from .archiver import Archiver, ArchiveInfo, ArchiveStatus
from .config import read_configuration, Configuration


def epilog() -> str:
    return """
The following snippet illustrates the required structure of the configuration YAML file:

temp-dir: C:\\temp
destination-dir: D:\BACKUP
targets:
  - description: CV + related documents
    source-path: C:\Home\CV
    archive-name: CV
  - description: Keepass database
    source-path: C:\Home
    archive-name: Keepass
    include-patterns:
      - .+KeePassDB.kdbx$
  - description: Knowledge-Base
    source-path: C:\Home\Knowledge-Base
    archive-name: Knowledge-base
    exclude-patterns:
      - .+\.zip$
      - .+\.mp3$

Each target corresponds to a single source directory structure which will be archived
to a single ZIP file. Each target can have an optional list of include or exclude
patterns.  Include and exclude patterns are mutually exclusive - single target cannot
have both include and exclude patterns. The patterns can be used to ensure that only
a subset of files present in the source directory structure will be archived. The
archive name is expected without file extension (.ZIP extension is automatically
generated by the backup tool). At the end of the backup process, the created archive(s)
will end up in a subdirectory of the specified destination directory. The name of the
subdirectory will be dervied from the current date and time.
"""


def create_cmd_line_args_parser() -> ArgumentParser:
    parser = ArgumentParser(description="Rudimentary Backup Tool", epilog=epilog(), formatter_class=RawTextHelpFormatter)

    # positional mandatory arguments
    parser.add_argument(
        "config_file",
        help="the name of the configuration YAML file"
    )

    # optional arguments
    parser.add_argument(
        "-o", "--output-html",
        dest="output_html_file",
        default=None,
        help="the optional name of an HTML output file the report is to be written to"
    )

    return parser


def parse_cmd_line_args() -> Namespace:
    parser = create_cmd_line_args_parser()
    params = parser.parse_args()
    return params


def current_timestamp() -> str:
    return datetime.now().strftime("%Y%m%d-%H%M%S")


def create_backup(configuration: Configuration, console: Console) -> list[ArchiveInfo]:
    target_count = len(configuration.targets)
    archive_info_list = []
    destination_dir = join(configuration.destination_dir, current_timestamp())
    makedirs(destination_dir, exist_ok=True)
    with console.status("[bold][blue]Archiving target...[/blue][bold]"):
        for index, target in enumerate(configuration.targets):
            archiver = Archiver(target, configuration.temp_dir, destination_dir)
            archive_info = archiver.create_archive()
            archive_info_list.append(archive_info)
            console.print(f"Target [green][bold]{target.description}[/green][/bold] ({index + 1}/{target_count}) archived")
        console.print("[bold][green]All targets archived.[/bold][/green]")
    return archive_info_list


def print_summary(archive_info_list: list[ArchiveInfo], console: Console) -> None:
    table = Table(title="Summary", show_lines=True)

    table.add_column("Target", justify="left")
    table.add_column("Archived Files", justify="right")
    table.add_column("Archived Bytes", justify="right")
    table.add_column("Ignored Files", justify="right")
    table.add_column("Archive Size", justify="right")
    table.add_column("Status", justify="center")
    
    for archive_info in archive_info_list:
        if archive_info.status == ArchiveStatus.OK:
            table.add_row(
                archive_info.target.description,
                str(archive_info.archived_file_count) if archive_info.archived_file_count else "",
                str(archive_info.archived_byte_count) if archive_info.archived_byte_count else "",
                str(archive_info.ignored_file_count) if archive_info.ignored_file_count else "",
                str(archive_info.archive_size) if archive_info.archive_size else "",
                archive_info.status.name
            )

    console.print(table)


def print_errors(archive_info_list: list[ArchiveInfo], console: Console) -> None:
    error_list = list(filter(lambda i: i.status == ArchiveStatus.FAILED, archive_info_list))
    if error_list is None or len(error_list) == 0:
        return

    table = Table(title="Errors", show_lines=True)

    table.add_column("Target", justify="left")
    table.add_column("Error", justify="right")

    for archive_info in error_list:
        table.add_row(
            archive_info.target.description,
            str(archive_info.error)
        )


def main() -> None:
    cmd_line_args = parse_cmd_line_args()
    console = Console(record=False)
    console.print()
    try:
        configuration = read_configuration(cmd_line_args.config_file)
        archive_info_list = create_backup(configuration, console)
        console = Console(record=True)
        print_summary(archive_info_list, console)
        print_errors(archive_info_list, console)
        if cmd_line_args.output_html_file:
            console.save_html(cmd_line_args.output_html_file)
    except Exception:
        console.print_exception(show_locals=False)


if __name__ == "__main__":
    main()
